import * as React from 'react';
import PropTypes from 'prop-types';
import { deepmerge } from '@mui/utils';
import defaultTranslations from '../translations';
import { jsx as _jsx } from "react/jsx-runtime";
var TranslationsContext = /*#__PURE__*/React.createContext(defaultTranslations);
function TranslationsProvider(_ref) {
  var _ref$translations = _ref.translations,
    translations = _ref$translations === void 0 ? {} : _ref$translations,
    children = _ref.children;
  var currentTranslations = React.useContext(TranslationsContext);
  var mergedTranslations = React.useMemo(function () {
    return deepmerge(currentTranslations, translations);
  }, [currentTranslations, translations]);
  return /*#__PURE__*/_jsx(TranslationsContext.Provider, {
    value: mergedTranslations,
    children: children
  });
}
function getPath(obj, path) {
  if (!path || typeof path !== 'string') {
    return null;
  }
  return path.split('.').reduce(function (acc, item) {
    return acc && acc[item] ? acc[item] : null;
  }, obj);
}
var UserLanguageContext = /*#__PURE__*/React.createContext({
  userLanguage: '',
  setUserLanguage: function setUserLanguage() {}
});
if (process.env.NODE_ENV !== 'production') {
  UserLanguageContext.displayName = 'UserLanguage';
}
export function UserLanguageProvider(props) {
  var children = props.children,
    translations = props.translations,
    defaultUserLanguage = props.defaultUserLanguage;
  var _React$useState = React.useState(defaultUserLanguage),
    userLanguage = _React$useState[0],
    setUserLanguage = _React$useState[1];
  var contextValue = React.useMemo(function () {
    return {
      userLanguage: userLanguage,
      setUserLanguage: setUserLanguage
    };
  }, [userLanguage]);
  return /*#__PURE__*/_jsx(TranslationsProvider, {
    translations: translations,
    children: /*#__PURE__*/_jsx(UserLanguageContext.Provider, {
      value: contextValue,
      children: children
    })
  });
}
process.env.NODE_ENV !== "production" ? UserLanguageProvider.propTypes = {
  children: PropTypes.node.isRequired,
  defaultUserLanguage: PropTypes.string
} : void 0;
export function useUserLanguage() {
  return React.useContext(UserLanguageContext).userLanguage;
}
export function useSetUserLanguage() {
  return React.useContext(UserLanguageContext).setUserLanguage;
}
var warnedOnce = {};
export function useTranslate() {
  var userLanguage = useUserLanguage();
  var translations = React.useContext(TranslationsContext);
  return React.useMemo(function () {
    return function translate(key) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var _options$ignoreWarnin = options.ignoreWarning,
        ignoreWarning = _options$ignoreWarnin === void 0 ? false : _options$ignoreWarnin;
      var wordings = translations[userLanguage];
      if (!wordings) {
        console.error("Missing language: ".concat(userLanguage, "."));
        return 'â€¦';
      }
      var translation = getPath(wordings, key);
      if (!translation) {
        var fullKey = "".concat(userLanguage, ":").concat(key);
        // No warnings in CI env
        if (!ignoreWarning && !warnedOnce[fullKey] && typeof window !== 'undefined') {
          console.error("Missing translation for ".concat(fullKey));
          warnedOnce[fullKey] = true;
        }
        return getPath(translations.en, key);
      }
      return translation;
    };
  }, [userLanguage, translations]);
}
export function mapTranslations(req) {
  var result = {};
  req.keys().forEach(function (filename) {
    var match = filename.match(/-([a-z]{2}).json$/);
    if (match) {
      result[match[1]] = req(filename);
    } else {
      result.en = req(filename);
    }
  });
  return result;
}