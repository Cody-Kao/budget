"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UserLanguageProvider = UserLanguageProvider;
exports.mapTranslations = mapTranslations;
exports.useSetUserLanguage = useSetUserLanguage;
exports.useTranslate = useTranslate;
exports.useUserLanguage = useUserLanguage;
var React = _interopRequireWildcard(require("react"));
var _propTypes = _interopRequireDefault(require("prop-types"));
var _utils = require("@mui/utils");
var _translations = _interopRequireDefault(require("../translations"));
var _jsxRuntime = require("react/jsx-runtime");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const TranslationsContext = /*#__PURE__*/React.createContext(_translations.default);
function TranslationsProvider({
  translations = {},
  children
}) {
  const currentTranslations = React.useContext(TranslationsContext);
  const mergedTranslations = React.useMemo(() => (0, _utils.deepmerge)(currentTranslations, translations), [currentTranslations, translations]);
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(TranslationsContext.Provider, {
    value: mergedTranslations,
    children: children
  });
}
function getPath(obj, path) {
  if (!path || typeof path !== 'string') {
    return null;
  }
  return path.split('.').reduce((acc, item) => acc && acc[item] ? acc[item] : null, obj);
}
const UserLanguageContext = /*#__PURE__*/React.createContext({
  userLanguage: '',
  setUserLanguage: () => {}
});
if (process.env.NODE_ENV !== 'production') {
  UserLanguageContext.displayName = 'UserLanguage';
}
function UserLanguageProvider(props) {
  const {
    children,
    translations,
    defaultUserLanguage
  } = props;
  const [userLanguage, setUserLanguage] = React.useState(defaultUserLanguage);
  const contextValue = React.useMemo(() => {
    return {
      userLanguage,
      setUserLanguage
    };
  }, [userLanguage]);
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(TranslationsProvider, {
    translations: translations,
    children: /*#__PURE__*/(0, _jsxRuntime.jsx)(UserLanguageContext.Provider, {
      value: contextValue,
      children: children
    })
  });
}
process.env.NODE_ENV !== "production" ? UserLanguageProvider.propTypes = {
  children: _propTypes.default.node.isRequired,
  defaultUserLanguage: _propTypes.default.string
} : void 0;
function useUserLanguage() {
  return React.useContext(UserLanguageContext).userLanguage;
}
function useSetUserLanguage() {
  return React.useContext(UserLanguageContext).setUserLanguage;
}
const warnedOnce = {};
function useTranslate() {
  const userLanguage = useUserLanguage();
  const translations = React.useContext(TranslationsContext);
  return React.useMemo(() => function translate(key, options = {}) {
    const {
      ignoreWarning = false
    } = options;
    const wordings = translations[userLanguage];
    if (!wordings) {
      console.error(`Missing language: ${userLanguage}.`);
      return 'â€¦';
    }
    const translation = getPath(wordings, key);
    if (!translation) {
      const fullKey = `${userLanguage}:${key}`;
      // No warnings in CI env
      if (!ignoreWarning && !warnedOnce[fullKey] && typeof window !== 'undefined') {
        console.error(`Missing translation for ${fullKey}`);
        warnedOnce[fullKey] = true;
      }
      return getPath(translations.en, key);
    }
    return translation;
  }, [userLanguage, translations]);
}
function mapTranslations(req) {
  const result = {};
  req.keys().forEach(filename => {
    const match = filename.match(/-([a-z]{2}).json$/);
    if (match) {
      result[match[1]] = req(filename);
    } else {
      result.en = req(filename);
    }
  });
  return result;
}